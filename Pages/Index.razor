@page "/"
@inject IJSRuntime JsRuntime
@inject NavigationManager NavigationManager

<PageTitle>CRC Calculator</PageTitle>

<div class="Encoding-Btn-Div">
    <button style="background-color:@Buttons.BackgroundColor.asciiBtn" class="ASCIIButton"
            @onclick="(() => SetEncodingOnClick(ENCODING.ASCII))">
        <strong>ASCII</strong>
    </button>
    <button style="background-color:@Buttons.BackgroundColor.hexBtn" class="HEXButton"
            @onclick="(() => SetEncodingOnClick(ENCODING.HEX))">
        <strong>HEX</strong>
    </button>
    <br>
    <br>
</div>

<div class="Input-Field-Div">
    <textarea class="input-field" rows="3" cols="60" name="text" @onkeyup="@UpdateCRC"
              @oninput="@((e) => {inputValue = (string?)e.Value;})"
              placeholder="Hello World!"></textarea>
</div>

<div class="Degree-Btn-Div">

    <br>

    @{
        var btnCounter = 0;
    }

    @if (crcBtnNames is not null)
    {
        @foreach (var btn in crcBtnNames)
        {
            <button style="background-color:@Buttons.buttonBackgrounds[2]" class="CRCButton"
                    @onclick="(() => SetDegreeOnClick(btnCounter))">
                <strong>@crcBtnNames[btnCounter]</strong>
            </button>
            btnCounter++;
        }
    }

</div>

<div class="result-View">
    <table class="table">
        <thead>
            <tr>
                <th><strong>@crcTypeHeaderText</strong></th>
                <th><strong>@resultHeaderText</strong></th>
                <th><strong>@polyHeaderText</strong></th>
                <th><strong>@InitialHeaderText</strong></th>
                <th><strong>@refInHeaderText</strong></th>
                <th><strong>@refOutHeaderText</strong></th>
                <th><strong>@xorOutHeaderText</strong></th>
            </tr>
        </thead>
        <tbody>
            @foreach (CRC c in @crcs)
            {
                if (c.deg == currentDegree)
                {
                    <tr>
                        <td><strong>@(c.name)</strong></td>
                        <td><strong>@(DetermineNibbles(currentDegree, c.result))</strong></td>
                        <td><strong>@(DetermineNibbles(currentDegree, c.poly))</strong></td>
                        <td><strong>@(DetermineNibbles(currentDegree, c.init))</strong></td>
                        <td><strong>@(c.ref_in.ToString())</strong></td>
                        <td><strong>@(c.ref_out.ToString())</strong></td>
                        <td><strong>@(DetermineNibbles(currentDegree, c.xor_out))</strong></td>
                    </tr>
                }
            }

        </tbody>

    </table>

</div>

@functions
{
    public static string DetermineNibbles(DEGREE deg, UInt32 input)
    {
        switch (deg)
        {
            case DEGREE.CRC4:
                return String.Format("0x{0:X1}", input);
            case DEGREE.CRC5:
            case DEGREE.CRC7:
            case DEGREE.CRC8:
                return String.Format("0x{0:X2}", input);
            case DEGREE.CRC15:
            case DEGREE.CRC16:
                return String.Format("0x{0:X4}", input);
            case DEGREE.CRC24:
                return String.Format("0x{0:X6}", input);
            case DEGREE.CRC32:
                return String.Format("0x{0:X8}", input);
            default: return string.Empty;
        }
    }
}

@code
{
    private int windowHeight { get; set; }
    private int windowWidth { get; set; }
    public enum ENCODING { ASCII, HEX }
    private static ENCODING currentEncoding { get; set; }
    public static DEGREE currentDegree { get; set; }
    static byte[] payload = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
    private static string? inputValue { get; set; } = "Hello World!";
    private static string? crcTypeHeaderText;
    private string? resultHeaderText;
    private string? polyHeaderText;
    private string? InitialHeaderText;
    private string? refInHeaderText;
    private string? refOutHeaderText;
    private string? xorOutHeaderText;

    private string[] approvedDomains = { "example.com" }; // Replace with your approved domains
    private string versionFilePath = "https://example.com/version.txt"; // Replace with the actual URL of your version file
    private string? remoteVersion;
    private byte[] YourLocalVersionBytes = Encoding.ASCII.GetBytes("v1.0");
    private byte[]? remoteVersionBytes;
    private bool versionCheckPassed = true;

    private string[]? crcBtnNames;

    static CRC[] crcs = new CRC[]{
        new CRC(DEGREE.CRC32, "/ (ETH/HDLC)", 0x04C11DB7, 0xFFFFFFFF,  true,  true, 0xFFFFFFFF),
        new CRC(DEGREE.CRC32, "C/INTERLAKEN", 0x1EDC6F41, 0xFFFFFFFF,  true,  true, 0xFFFFFFFF),
        new CRC(DEGREE.CRC32, "/SATA       ", 0x04C11DB7, 0x52325032, false, false, 0x00000000),
        new CRC(DEGREE.CRC32, "/POSIX      ", 0x04C11DB7, 0x00000000, false, false, 0xFFFFFFFF),
        new CRC(DEGREE.CRC32, "/BZIP2      ", 0x04C11DB7, 0xFFFFFFFF, false, false, 0xFFFFFFFF),
        new CRC(DEGREE.CRC32, "/JAMCRC     ", 0x04C11DB7, 0xFFFFFFFF,  true,  true, 0x00000000),
        new CRC(DEGREE.CRC32, "/XFER       ", 0x000000AF, 0x00000000, false, false, 0x00000000),
        new CRC(DEGREE.CRC32, "/CD-ROM-EDC ", 0x8001801B, 0x00000000,  true,  true, 0x00000000),
        new CRC(DEGREE.CRC24, "/INTERLAKEN ", 0x328B63, 0xFFFFFF, false, false, 0xFFFFFF),
        new CRC(DEGREE.CRC24, "/LTE-A      ", 0x864CFB, 0x000000, false, false, 0x000000),
        new CRC(DEGREE.CRC24, "/LTE-B      ", 0x800063, 0x000000, false, false, 0x000000),
        new CRC(DEGREE.CRC24, "/BLE        ", 0x00065B, 0x555555,  true,  true, 0x000000),
        new CRC(DEGREE.CRC16, "/CCITT      ", 0x1021, 0x0000,  true,  true, 0x0000),
        new CRC(DEGREE.CRC16, "/CCITT-FALSE", 0x1021, 0xFFFF, false, false, 0x0000),
        new CRC(DEGREE.CRC16, "/BLUETOOTH  ", 0x1021, 0x0000,  true,  true, 0x0000),
        new CRC(DEGREE.CRC16, "/CDMA2000   ", 0xC867, 0xFFFF, false, false, 0x0000),
        new CRC(DEGREE.CRC16, "/MODBUS     ", 0x8005, 0xFFFF,  true,  true, 0x0000),        new CRC(DEGREE.CRC16, "/PROFIBUS   ", 0x1DCF, 0xFFFF, false, false, 0x0000),
        new CRC(DEGREE.CRC16, "/USB        ", 0x8005, 0xFFFF,  true,  true, 0xFFFF),
        new CRC(DEGREE.CRC15, "/CAN        ", 0x4599, 0x0000, false, false, 0x0000),
        new CRC(DEGREE.CRC8,  "/ (SMBus)   ", 0x07, 0x00, false, false, 0x00),
        new CRC(DEGREE.CRC8,  "/SPACEWIRE  ", 0x07, 0x00, false, false, 0x00),
        new CRC(DEGREE.CRC8,  "/ITU (ATM)  ", 0x07, 0x00, false, false, 0x55),
        new CRC(DEGREE.CRC8,  "/LTE        ", 0x9B, 0x00, false, false, 0x00),
        new CRC(DEGREE.CRC8,  "/BLUETOOTH  ", 0xA7, 0x00,  true,  true, 0x00),
        new CRC(DEGREE.CRC8,  "/CDMA2000   ", 0x9B, 0xFF, false, false, 0x00),
        new CRC(DEGREE.CRC8,  "/DVB-S2     ", 0xD5, 0x00, false, false, 0x00),
        new CRC(DEGREE.CRC7,  "/eMMC       ", 0x09, 0x00, false, false, 0x00),
        new CRC(DEGREE.CRC5,  "/USB        ", 0x05, 0x1F,  true,  true, 0x1F),
        new CRC(DEGREE.CRC4,  "/INTERLAKEN ", 0x3, 0xF, false, false, 0xF),
        new CRC(DEGREE.CRC4,  "/G-704      ", 0x3, 0x0,  true,  true, 0x0)
    };

    protected override async Task OnInitializedAsync()
    {
        await CheckRemoteVersion();

        if (versionCheckPassed)
        {
            crcBtnNames = new string[]
            {
            "CRC-4", "CRC-5", "CRC-7", "CRC-8", "CRC-15", "CRC-16", "CRC-24", "CRC-32"
            };

            Buttons.SetCurrentEncoding(ENCODING.ASCII);
            Buttons.SetCurrentDegree((int)DEGREE.CRC32);
            var dimension = await JsRuntime.InvokeAsync<WindowDimension>("getWindowDimensions");
            windowHeight = dimension.Height;
            windowWidth = dimension.Width;
            crcTypeHeaderText = currentDegree.ToString() + "/";
            resultHeaderText = "Result";
            polyHeaderText = "Polynomial";
            InitialHeaderText = "Initial";
            refInHeaderText = "Ref In";
            refOutHeaderText = "Ref Out";
            xorOutHeaderText = "XOR Out";

            UpdateCRC();
        }
    }

    public class WindowDimension
    {
        public int Width { get; set; }
        public int Height { get; set; }
    }

    private static void UpdateCRC()
    {
        if (currentEncoding is ENCODING.ASCII)
        {
            if (inputValue is not null)
            {
                payload = Encoding.ASCII.GetBytes(inputValue);
            }
        }
        else
        {
            if (inputValue is not null)
            {
                string? noFixHex = inputValue.Replace("0x", "")
                .Replace("h", "").Replace("\r", "").Replace("\n", "");
                string? noSpaceHex = noFixHex.Trim();
                if (!IsHex(noSpaceHex)) { return; }
                byte[] asciiHex = Encoding.ASCII.GetBytes(noSpaceHex);
                bool isOdd = (asciiHex.Length % 2) > 0;
                byte[] nibbles = new byte[asciiHex.Length + (isOdd ? 1 : 0)];
                for (int n = 0; n < asciiHex.Length; n++) { nibbles[n] = asciiHex[n]; }
                if (isOdd)
                {
                    nibbles[nibbles.Length - 1] = nibbles[nibbles.Length - 2];
                    nibbles[nibbles.Length - 2] = 0x30;
                }
                payload = new byte[nibbles.Length / 2];
                for (int i = 0; i < payload.Length; i++)
                {
                    byte u = 0;
                    byte l = 0;
                    u = (byte)(NibbleToByte(nibbles[i * 2]) << 4);
                    l = (byte)(NibbleToByte(nibbles[i * 2 + 1]) & 0x0f);
                    payload[i] = (byte)(u | l);
                }
            }
        }
        for (int c = 0; c < crcs.Length; c++)
        {
            { if (crcs[c].deg == currentDegree) { LFSR_CRC.ComputeCRC(ref crcs[c], payload); } }
        }
        crcTypeHeaderText = currentDegree.ToString() + "/";
    }

    private void onChange(ChangeEventArgs args)
    {
        Console.WriteLine("Input detected");
        inputValue = args.Value as string;

        UpdateCRC();
    }

    private void SetEncodingOnClick(ENCODING encodingType) { Buttons.SetCurrentEncoding(encodingType); }

    private void SetDegreeOnClick(int degreeType) { Buttons.SetCurrentDegree(degreeType); }

    public static bool IsHex(string input) { return System.Text.RegularExpressions.Regex.IsMatch(input, @"\A\b[0-9a-fA-F]+\b\Z"); }

    public static byte NibbleToByte(byte byt)
    {
        if (byt < 58) { return (byte)(byt - 0x30); }
        if (byt < 71) { return (byte)(byt - 0x41); }
        if (byt < 103) { return (byte)(byt - 0x61); }
        return 0;
    }

    private struct Buttons
    {
        //white
        public static string? primaryColor = "#fffff";
        //blue
        public static string? secondaryColor = "#3898ec";
        public static int previousIndex;

        public static string?[] buttonBackgrounds =
        {
            Buttons.BackgroundColor.crc4Btn,
            Buttons.BackgroundColor.crc5Btn,
            Buttons.BackgroundColor.crc7Btn,
            Buttons.BackgroundColor.crc8Btn,
            Buttons.BackgroundColor.crc15Btn,
            Buttons.BackgroundColor.crc16Btn,
            Buttons.BackgroundColor.crc24Btn,
            Buttons.BackgroundColor.crc32Btn
    };

        public static void SetCurrentEncoding(Enum? enumValue)
        {
            switch (enumValue)
            {
                case ENCODING.ASCII:
                    currentEncoding = ENCODING.ASCII;
                    Buttons.BackgroundColor.asciiBtn = secondaryColor;
                    Buttons.BackgroundColor.hexBtn = primaryColor;
                    break;
                case ENCODING.HEX:
                    currentEncoding = ENCODING.HEX;
                    Buttons.BackgroundColor.hexBtn = secondaryColor;
                    Buttons.BackgroundColor.asciiBtn = primaryColor;
                    break;
            }

            UpdateCRC();
        }

        public static void SetCurrentDegree(int enumValue)
        {
            switch (enumValue)
            {
                case 0:
                    buttonBackgrounds[previousIndex] = primaryColor;
                    currentDegree = DEGREE.CRC4;
                    previousIndex = (int)DEGREE.CRC4;
                    buttonBackgrounds[previousIndex] = secondaryColor;
                    break;
                case 1:
                    buttonBackgrounds[previousIndex] = primaryColor;
                    currentDegree = DEGREE.CRC5;
                    previousIndex = (int)DEGREE.CRC5;
                    buttonBackgrounds[previousIndex] = secondaryColor;
                    break;
                case 2:
                    buttonBackgrounds[previousIndex] = primaryColor;
                    currentDegree = DEGREE.CRC7;
                    previousIndex = (int)DEGREE.CRC7;
                    buttonBackgrounds[previousIndex] = secondaryColor;
                    break;
                case 3:
                    buttonBackgrounds[previousIndex] = primaryColor;
                    currentDegree = DEGREE.CRC8;
                    previousIndex = (int)DEGREE.CRC8;
                    buttonBackgrounds[previousIndex] = secondaryColor;
                    break;
                case 4:
                    buttonBackgrounds[previousIndex] = primaryColor;
                    currentDegree = DEGREE.CRC15;
                    previousIndex = (int)DEGREE.CRC15;
                    buttonBackgrounds[previousIndex] = secondaryColor;
                    break;
                case 5:
                    buttonBackgrounds[previousIndex] = primaryColor;
                    currentDegree = DEGREE.CRC16;
                    previousIndex = (int)DEGREE.CRC16;
                    buttonBackgrounds[previousIndex] = secondaryColor;
                    break;
                case 6:
                    buttonBackgrounds[previousIndex] = primaryColor;
                    currentDegree = DEGREE.CRC24;
                    previousIndex = (int)DEGREE.CRC24;
                    buttonBackgrounds[previousIndex] = secondaryColor;
                    break;
                case 7:
                    buttonBackgrounds[previousIndex] = primaryColor;
                    currentDegree = DEGREE.CRC32;
                    previousIndex = (int)DEGREE.CRC32;
                    buttonBackgrounds[previousIndex] = secondaryColor;
                    break;
            }

            UpdateCRC();

        }

        public static class BackgroundColor
        {
            public static string? asciiBtn { get; set; }
            public static string? hexBtn { get; set; }
            public static string? crc4Btn { get; set; }
            public static string? crc5Btn { get; set; }
            public static string? crc7Btn { get; set; }
            public static string? crc8Btn { get; set; }
            public static string? crc15Btn { get; set; }
            public static string? crc16Btn { get; set; }
            public static string? crc24Btn { get; set; }
            public static string? crc32Btn { get; set; }
        }
    }

    private async Task CheckRemoteVersion()
    {
        try
        {
            // Check if the current domain is approved
            if (!IsApprovedDomain())
            {
                Console.WriteLine("Domain not approved. Aborting operation.");
                return;
            }

            // Fetch the binary file content
            using (var httpClient = new HttpClient())
            {
                remoteVersionBytes = await httpClient.GetByteArrayAsync(versionFilePath);

                // Process the binary data or update your UI accordingly
                Console.WriteLine($"Binary data fetched. Length: {remoteVersionBytes.Length}");

                // Check if versions match
                if (CheckVersionsMatch(remoteVersionBytes))
                {
                    versionCheckPassed = true;
                    Console.WriteLine("Versions match. Proceeding with the application logic.");
                    // Proceed with any additional initialization logic
                }
                else
                {
                    versionCheckPassed = false;
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error fetching remote version: {ex.Message}");
            // Handle the error (e.g., show an error message)
            versionCheckPassed = false;
        }
    }

    private bool IsApprovedDomain()
    {
        // Check if the current domain is approved
        return approvedDomains.Any(domain => NavigationManager.Uri.Contains(domain, StringComparison.OrdinalIgnoreCase));
    }

    private bool CheckVersionsMatch(byte[] remoteVersionBytes)
    {
        // Compare the remote version binary data with your local version
        // Assuming the version is represented as ASCII characters

        // Convert the remote version bytes to a string
        string remoteVersion = Encoding.ASCII.GetString(remoteVersionBytes).Trim();

        // Convert the local version bytes to a string
        string localVersion = Encoding.ASCII.GetString(YourLocalVersionBytes).Trim();

        // Implement your specific comparison logic based on version numbers
        return string.Equals(remoteVersion, localVersion, StringComparison.OrdinalIgnoreCase);
    }

    private void ShowErrorMessage(string message)
    {
        // Implement how you want to display or handle the error message
        // For example, you can use a modal, display a toast, or log the error
        Console.WriteLine($"Error: {message}");
    }
}

